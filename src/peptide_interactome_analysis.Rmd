---
title: "PPI analysis"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
    code_folding: hide
    theme: united
author: Bora Uyar
---

`r date()`


# Motivation

We are interested to see if the proteins detected as significant interaction partners of peptides also interact with each other. If so, how dense are the sub-interactome detected for each peptide? Is it denser than expected by chance? This will be addressed by PPI analysis. 

Similarly, are the proteins detected for a peptide more similar to each other (in terms of sequence/function) than expected by chance? This will be addressed by looking into the protein sequence embeddings derived using Transformers. 

# Setup

Import required libraries
```{r setup}
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F, fig.height = 7, fig.width = 9)
suppressPackageStartupMessages(library(slimR))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(parallel))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(igraph))
ggplot2::theme_set(ggpubr::theme_pubclean())
datadir <- '/data/local/buyar/collaborations/trendelina/data'
```

Import LFQ data (scaled, see LFQ_slim_domain_analysis.R output)
```{r}
uniprot2geneName <- readRDS('/data/local/buyar/datasets/uniprot2hgnc.RDS')
# import LFQ scores normalized w.r.t peptides (some proteins tend to bind all peptides)
lfqScaled <- readRDS('/data/local/buyar/collaborations/trendelina/LFQ_scaled.RDS')
lfq <- dcast(lfqScaled, uniprotAccession ~ type + Expgroup)
lfq <- as.matrix(data.frame(lfq[,-1], row.names = lfq$uniprotAccession))
```

## PPI subnetworks 
Import StringDB interactome, map ensembl ids to uniprot ids 
```{r}
# import ppi network (ensembl gene ids)
ppi <- data.table::fread('/data/local/buyar/datasets/interactome/string/stringdb.v11.adj_matrix.ensg.csv')
ens2hgnc <- readRDS('/data/local/buyar/datasets/ens2hgnc.RDS')
uniprot2hgnc <- readRDS('/data/local/buyar/datasets/uniprot2hgnc.RDS')
ens2uniprot <- ens2hgnc
ens2uniprot$uniprotAccession <- uniprot2hgnc[match(ens2uniprot$hgnc_symbol, geneName)]$uniprotAccession
ens2uniprot <- ens2uniprot[!is.na(uniprotAccession)]
# convert ppi from ensembl ids to uniprot accessions
selected <- intersect(ens2uniprot$ref_gene_id, colnames(ppi))
ppi <- as.matrix(data.frame(ppi[,-1], row.names = ppi$V1))
ppi <- ppi[selected, selected]
rownames(ppi) <- ens2uniprot[match(rownames(ppi), ref_gene_id)]$uniprotAccession
colnames(ppi) <- ens2uniprot[match(colnames(ppi), ref_gene_id)]$uniprotAccession

# find genes which exist in the whole array data and have ppi data
nodes <- unique(intersect(rownames(lfq), colnames(ppi)))
ppi.subset <- ppi[nodes, nodes]

# get igpraph object for LFQ interactome
adj <- igraph::graph.adjacency(ppi.subset)
```

For each peptide, compute the subnetwork density of the interaction partners.
Split interaction partners into groups of fixed size by order of their rank for the peptide.
For each group, compute network density
```{r}
V <- igraph::vertex.attributes(adj)[['name']] # global ppi
# for each peptide, remove those that are not in the ppi, and sort them by LFQ values

interactors <- pbapply::pbsapply(simplify = F, colnames(lfq), function(peptide) {
  names(sort(lfq[V, peptide], decreasing = T))
})

stats <- do.call(rbind, sapply(simplify = F, names(interactors), function(peptide) {
  # split interactors into groups of 50 
  bins <- 0:floor(length(interactors[[peptide]])/50-1)
  do.call(rbind, lapply(bins, function(i) {
    st <- i*50+1
    end <- (i+1)*50
    v <- interactors[[peptide]][st:end]#get a subnetwork consisting of proteins between these ranks
    sg <- igraph::subgraph(adj, v) #get subgraph from the vertices and compute stats
    d <- igraph::edge_density(sg)
    data.table('density' = d, 'rank' = i+1, 'peptide' = peptide)
  }))
}))

```


Check if there is a correlation between LFQ ranking and subgraph density. Are highly ranked 
proteins for a peptide also more densely connected in the interactome?

```{r}
ggboxplot(stats, x = 'rank', y = 'density')
# find peptides with high correlation with rank and density
m <- dcast(stats, peptide ~ rank, value.var = 'density')
m <- as.matrix(data.frame(m[,-1], row.names = m$peptide))
sort(apply(m, 1, function(x) cor(x, 1:34, method = 'spearman')))
```

I don't observe a global decrease in density as we check lower ranking proteins. 
For some peptides, there a correlation, but for some there is an equally strong negative 
correlation. So, probably, high LFQ values is not associated to more highly connected subnetworks. 


## Protein embeddings

I also want to check if proteins binding to a peptide are more similar to each other 
than proteins that preferentially bind to other peptides

I use the scaled LFQ scores to pick top 100 proteins per peptide and 
compute the pairwise correlaiton scores (based on embeddings). Then I compare the 
distribution of correlation scores for proteins that are co-members for a peptide
and proteins that are not co-members.

Import protein embeddings 
```{r}
E <- data.table::fread('/data/local/buyar/arcas/protein_embeddings/prot_trans/embeddings/uniprot/embeddings.protein_level.csv')
E <- t(as.matrix(data.frame(E[,-1], row.names = paste0('E', E$V1))))

# subset embeddings for proteins in the LFQ table
E <- E[intersect(rownames(E), rownames(lfq)),]
```

For each peptide, compute correlation between its interaction partners (high ranking ones)
and compare it to the background

```{r}
# get correlation matrix between pairs of proteins
M <- cor(t(E))

# stats using embeddings
stats_emb <- do.call(rbind, pbapply::pbsapply(simplify = F, names(interactors), function(peptide) {
  # get top interactors for the peptide
  v <- intersect(interactors[[peptide]][1:25], colnames(M))
  # get the rest
  vn <- setdiff(colnames(M), v)
  # get correlation scores for the peptide interactors and non-interactors
  c1 <- M[v,v]
  c1 <- c1[upper.tri(c1, diag = F)]# get unique comparisons, remove diagonal
  c2 <- as.numeric(M[v,vn])
  t <- wilcox.test(c1, c2, alternative = 'greater')
  data.table('peptide' = peptide, 'comembers' = mean(c1), 'others' = mean(c2), 'pval' = t$p.value)
}))



```

For 92 out of 117 peptides, we get a significant within-members similarity (w.r.t embeddings)
than out-members 

Make a t-sne of protein embeddings colored by peptides/lfq scores
- Some peptides will have similar list of proteins, so I cluster the peptides
by LFQ values first. Then for each cluster I pick top proteins per peptide and
get a union of them. 
- Color the tsne plot by cluster specific proteins

```{r}
# take mut_106 as example

df <- data.frame(Rtsne::Rtsne(E)[['Y']])
rownames(df) <- rownames(E)
colnames(df) <- c('tSNE1', 'tSNE2')

# assign each protein to a peptide (only if it is in top 100 of that peptide)
# for proteins that are found for multiple peptides, pick the peptide with highest value
#df$peptide <- apply(lfq[rownames(df),], 1, function(x) names(x)[which.max(x)])
#df$group <- ifelse(df$peptide %in% names(which(table(df$peptide) > 30)), df$peptide, NA)
# plot top 10 peptides with most proteins 

plots <- pbapply::pbsapply(simplify = F, stats_emb[order(pval)]$peptide, function(p) {
  df$pep <- ifelse(rownames(df) %in% interactors[[p]][1:100], p, NA)
  ggscatter(df, x = 'tSNE1', y = 'tSNE2', color = 'pep') +
    theme(legend.position = 'none') + labs(title = p)
})

```

Depending on the top proteins picked per peptide, I get different set of peptides that show 
increased average correlation between co-members vs non-members. When I color them on tSNE
plot, I don't see them clustering in the embedding space. 


Try plotting a tSNE of the LFQ 
```{r}
df2 <- data.frame(Rtsne::Rtsne(lfq)[['Y']])
rownames(df2) <- rownames(lfq)
colnames(df2) <- c('tSNE1', 'tSNE2')
df2$peptide <- apply(lfq[rownames(df2),], 1, function(x) names(x)[which.max(x)])
df2$expgroup <- as.character(sub(".+_([0-9]+$)", "\\1", df2$peptide))
df2$group <- ifelse(df2$expgroup %in% names(which(table(df2$expgroup) > 80)), df2$expgroup, NA)
ggscatter(df2, x = 'tSNE1', y = 'tSNE2', color = 'group') 
# source('/data/local/buyar/arcas/uyar_et_al_multiomics_deeplearning/src/common_functions.R')
# plot_tsne(lfq, df2$group, show.labels = T) 
```

Cluster peptides, color heatmap by clusters
```{r}
cl <- get_spectral_clusters(t(lfq), k_vals = 10)
colnames(cl)[1] <- 'cluster'
cl$cluster <- as.factor(cl$cluster)
pheatmap::pheatmap(cor(lfq), annotation_row = cl)
df2$peptide_cluster <- cl[df2$peptide,]
ggscatter(df2, x = 'tSNE1', y = 'tSNE2', color = 'peptide_cluster') 

# assign expgroup to each cluster
cluster_labels <- lapply(split(cl, cl$cluster), function(x) {
  paste(sort(as.numeric(unique(sub(".+_([0-9]+$)", "\\1", rownames(x))))), collapse = '_')
})
df2$cluster_label <- unlist(cluster_labels[as.numeric(df2$peptide_cluster)])
ggscatter(df2, x = 'tSNE1', y = 'tSNE2', color = 'cluster_label') 

```



```{r}
p <- intersect(rownames(lfq), rownames(E))
l <- lfq[p,]
e <- E[p,]
lfq_cl <- get_kmeans_subtypes(lfq_cl, k_vals = 10)
```

See if protein embeddings can be used to predict lfq clusters
```{r}
evaluate_regression_model <- function(y, y_hat) {
  require(caret)
  # Model performance metrics
  data.table::data.table(
    RMSE = RMSE(y_hat, y),
    Rsquare = R2(y_hat, y),
    COR = cor(y_hat, y)
  )
}

cl <- parallel::makeCluster(10) 
parallel::clusterExport(cl = cl, varlist = c('evaluate_regression_model', 'e', 'l'))
results <- do.call(rbind, pbapply::pblapply(cl = cl, colnames(l), function(peptide) {
  require(data.table)
  df <- cbind(data.frame(e), data.frame('y' = as.factor(l[,peptide] > median(l[,peptide]))))
  s <- sample(rownames(df), round(nrow(df) * 0.7))
  df.train <- df[s,]
  df.test <- df[setdiff(rownames(df), s),]
  fit <- ranger::ranger(y ~ ., df.train, num.trees = 1000, num.threads = 2, importance = 'permutation')
  p <- predict(fit, df.test)
  #r <- evaluate_regression_model(df.test$y, p$predictions)
  r <- caret::confusionMatrix(p$predictions, df.test$y)
  r <- data.table(t(r$overall))
  r$peptide <- peptide
  return(r)
}))
parallel::stopCluster(cl)

# explore some of the peptides with good predictions
peptide <- 'phos_106'
df <- cbind(data.frame(e), data.frame('y' = as.factor(l[,peptide] > median(l[,peptide]))))
s <- sample(rownames(df), round(nrow(df) * 0.7))
df.train <- df[s,]
df.test <- df[setdiff(rownames(df), s),]
fit <- ranger::ranger(y ~ ., df.train, num.trees = 1000, num.threads = 2)
p <- predict(fit, df.test)
#r <- evaluate_regression_model(df.test$y, p$predictions)
r <- caret::confusionMatrix(p$predictions, df.test$y)
r <- data.table(t(r$overall))
ggplot(data.frame('index' = 1:nrow(df.test), 
                  'y' = l[rownames(df.test), peptide], 
                  'high' = p$predictions), 
       aes(x = reorder(index, y), y = y)) + 
  geom_point(aes(color = high)) 

ggviolin(data.frame('y' = l[rownames(df.test), peptide], 
                    'high' = p$predictions), 
          x = 'high', y = 'y', color = 'high', add = 'jitter') + 
  stat_compare_means()

ggplot(data.frame('y' = l[rownames(df.test), peptide], 
                    'high' = p$predictions), aes(x = y)) + geom_density(aes(fill = high), alpha = 0.25)

pheatmap(table(p$predictions, df.test$y))
```

We can predict for 55/117 peptides if the protein has a higher z-score than 0 for the given peptide 
with an accuracy of > 0.6.


# DescribePROT features

Instead of using sequence embeddings, use structural protein features to predict 
LFQ z-scores. 

Import describeprot data for the proteins in the screen. Then bin each protein into 100 bins, 
take average scores per bin. Thus, we get standardized features for all proteins 
```{r}
describePROT <- data.table::fread('/data/local/buyar/datasets/describePROT/9606_database.tsv')
# remove proteins shorter than 100 residues
describePROT <- describePROT[seqlength > 100]
to_remove <- c('ACC', 'ACC_entry', 'seq', 'seqlength', 'taxonomy_id',
                      'ProteinName', 'SignalP_score', 'MMseqs2_pssm',
               'MMseq2_conservation_level', 'ASAquick_rawscore')
p <- intersect(describePROT$ACC, rownames(lfq))
dp <- describePROT[ACC %in% p]

dp <- data.frame(subset(dp, select = setdiff(colnames(dp),to_remove)), row.names = dp$ACC)
# for each protein, bin the sequence into 100 pieces, get average per bin for each score

# get a matrix per protein
scores <- do.call(rbind, pbapply::pbsapply(simplify = F, rownames(dp), function(pro) {
  #message(pro)
  m <- t(do.call(cbind, sapply(simplify = F, colnames(dp), function(x) {
      as.numeric(unlist(strsplit(dp[pro,x], ",")))
    })))
  # bin the sequence into 100 pieces and get average per bin
  percentile <- ecdf(1:(ncol(m)+1))
  dt <- data.table(melt(m))
  dt$bin <- sapply(dt$Var2, function(pos) floor(percentile(pos)*100)+1)
  # get average score per bin
  dt <- dt[,mean(value),by = c('Var1', 'bin')]
  # convert to matrix form 
  dtc <- dcast(dt, bin ~ Var1, value.var = 'V1')
  m_binned <- t(as.matrix(dtc[,-1]))
  # normalize
  m_scaled <- t(scale(t(m_binned)))
  dt <- data.table(melt(m_scaled))
  dt$uniprotAccession <- pro
  # return tall form to rbind with other proteins
  return(dt)
}))

# get matrix form, thus we get a 100 (# bins) x 13 (# describe prot features) x ~2000 (# proteins in LFQ) => matrix of ~2000x1300
S <- dcast.data.table(scores, uniprotAccession ~ Var1 + Var2)
S <- as.matrix(data.frame(S[,-1], row.names = S$uniprotAccession))

```

Use describeprot features to predict LFQ scores

```{r}
L <- lfq[rownames(S),]

# given a matrix with some NA values, impute NA values by the median value in rows
impute_median <- function(M) {
  t(apply(M, 1, function(x) {
    x[is.na(x)] <- median(x, na.rm = T)
    return(x)
  }))
}

S <- t(impute_median(t(S)))

cl <- parallel::makeCluster(10) 
parallel::clusterExport(cl = cl, varlist = c('S', 'L'))
results <- do.call(rbind, pbapply::pblapply(cl = cl, colnames(L), function(peptide) {
  require(data.table)
  df <- cbind(data.frame(S), data.frame('y' = as.factor(L[,peptide] > median(L[,peptide]))))
  s <- sample(rownames(df), round(nrow(df) * 0.7))
  df.train <- df[s,]
  df.test <- df[setdiff(rownames(df), s),]
  fit <- ranger::ranger(y ~ ., df.train, num.trees = 1000, num.threads = 2, importance = 'permutation')
  p <- predict(fit, df.test)
  #r <- evaluate_regression_model(df.test$y, p$predictions)
  r <- caret::confusionMatrix(p$predictions, df.test$y)
  r <- data.table(t(r$overall))
  r$peptide <- peptide
  return(r)
}))
parallel::stopCluster(cl)


```

The position specific structural features didn't prove to be very predictive of lfq scores. 
This could be because subsequence of a protein could be just important for binding to the peptide, while its position in the protein might not be important at all. So, we need some kind of local motif search kind of algorithm to find a stretch of sequences with the given structural features 
shared across multiple proteins that preferentially bind to the target peptide. 

1. Extract a matrix of scores for each protein sequence with a moving window of e.g. 50 residues (each step of 10 residues)
2. Find pairwise correlation of all windows extracted for all proteins
3. Cluster the windows based on correlation (for windows coming from the same sequence (overlapping windows), only keep the window that has the maximum correlation to the other windows from other proteins)
4. If the cluster of proteins display enrichment of LFQ scores, then the cluster of protein segments 
might contain a structural feature that is important for binding the peptide. 













